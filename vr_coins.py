# -*- coding: utf-8 -*-
"""VR Coins

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jzYRNGpGmLh39waPAunRKjWBHL3cAVlb
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

image_path = 'Coins.jpg'

def detect_and_segment_coins(image_path):
    image = cv2.imread(image_path)
    original = image.copy()

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    blurred = cv2.GaussianBlur(gray, (11, 11), 0)

    edges = cv2.Canny(blurred, 30, 150)

    kernel = np.ones((5,5), np.uint8)
    dilated = cv2.dilate(edges, kernel, iterations=1)

    contours, _ = cv2.findContours(dilated.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    valid_contours = []
    for cnt in contours:
        area = cv2.contourArea(cnt)
        perimeter = cv2.arcLength(cnt, True)

        if perimeter > 0:
            circularity = 4 * np.pi * area / (perimeter * perimeter)
            if area > 250000 and circularity > 0.25:
                valid_contours.append(cnt)

    coins_detected = original.copy()
    cv2.drawContours(coins_detected, valid_contours, -1, (0, 255, 0), 2)

    segmented_coins = []
    for cnt in valid_contours:
        mask = np.zeros(gray.shape, np.uint8)
        cv2.drawContours(mask, [cnt], -1, 255, -1)
        coin = cv2.bitwise_and(original, original, mask=mask)
        x, y, w, h = cv2.boundingRect(cnt)
        aspect_ratio = float(w)/h
        if 0.7 <= aspect_ratio <= 1.3:
            coin_crop = coin[y:y+h, x:x+w]
            coin_crop = remove_black_borders(coin_crop)
            segmented_coins.append(coin_crop)

    return coins_detected, segmented_coins, len(segmented_coins)

def remove_black_borders(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    _, thresh = cv2.threshold(gray, 1, 255, cv2.THRESH_BINARY)

    coords = cv2.findNonZero(thresh)

    if coords is not None:
        x, y, w, h = cv2.boundingRect(coords)

        return image[y:y+h, x:x+w]
    return image

def display_results(coins_detected, segmented_coins, coin_count):
    fig = plt.figure(figsize=(20, 10))
    plt.clf()

    gs = plt.GridSpec(1, 2, width_ratios=[1, 1.5], figure=fig)

    ax1 = fig.add_subplot(gs[0])
    ax1.imshow(cv2.cvtColor(coins_detected, cv2.COLOR_BGR2RGB))
    ax1.set_title('Detected Coins', pad=20)
    ax1.axis('off')

    if len(segmented_coins) > 0:
        # Calculate grid dimensions
        n_coins = len(segmented_coins)
        n_cols = min(4, n_coins)
        n_rows = max(1, (n_coins + n_cols - 1) // n_cols)

        inner_gs = plt.GridSpec(n_rows, n_cols, wspace=0.3, hspace=0.4)
        inner_gs.update(left=0.55, right=0.95, top=0.9, bottom=0.1)

        for idx, coin in enumerate(segmented_coins):
            ax = fig.add_subplot(inner_gs[idx // n_cols, idx % n_cols])
            ax.imshow(cv2.cvtColor(coin, cv2.COLOR_BGR2RGB))
            ax.set_title(f'Coin {idx + 1}', pad=10)
            ax.axis('off')

    plt.suptitle(f'Total Coins Detected: {coin_count}',
                 fontsize=16,
                 y=0.95)

    plt.subplots_adjust(top=0.85, bottom=0.1, left=0.05, right=0.95)
    plt.show()

def debug_parameters(image_path):
    """Print debugging information about the image and detection process"""
    image = cv2.imread(image_path)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (11, 11), 0)
    edges = cv2.Canny(blurred, 30, 150)
    kernel = np.ones((5,5), np.uint8)
    dilated = cv2.dilate(edges, kernel, iterations=1)
    contours, _ = cv2.findContours(dilated.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    print(f"Image shape: {image.shape}")
    print(f"Number of contours found: {len(contours)}")

    for i, cnt in enumerate(contours):
        area = cv2.contourArea(cnt)
        perimeter = cv2.arcLength(cnt, True)
        circularity = 4 * np.pi * area / (perimeter * perimeter) if perimeter > 0 else 0
        print(f"Contour {i}: Area={area:.2f}, Circularity={circularity:.2f}")

coins_detected, segmented_coins, coin_count = detect_and_segment_coins(image_path)
display_results(coins_detected, segmented_coins, coin_count)

debug_parameters(image_path)

def segment(image_path):
    image = cv2.imread(image_path)
    if image is None:
        raise ValueError("Could not read image")
    original = image.copy()

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    blur = cv2.GaussianBlur(gray, (5, 5), 0)
    _, binary = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3,3))
    closing = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel, iterations=6)
    opening = cv2.morphologyEx(closing, cv2.MORPH_OPEN, kernel, iterations=1)

    contours, _ = cv2.findContours(opening, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    segmented_coins = []
    valid_contours = []

    if contours:
        min_area = 2000
        filtered_contours = [cnt for cnt in contours if cv2.contourArea(cnt) > min_area]

        if filtered_contours:
            areas = [cv2.contourArea(cnt) for cnt in filtered_contours]
            median_area = np.median(areas)

            for cnt in filtered_contours:
                area = cv2.contourArea(cnt)
                perimeter = cv2.arcLength(cnt, True)

                if area > median_area * 0.3:
                    valid_contours.append(cnt)

                    mask = np.zeros(gray.shape, dtype=np.uint8)
                    cv2.drawContours(mask, [cnt], -1, 255, -1)

                    masked_coin = cv2.bitwise_and(original, original, mask=mask)

                    # Bounding box (padding)
                    x, y, w, h = cv2.boundingRect(cnt)
                    padding = 5
                    x1 = max(0, x - padding)
                    y1 = max(0, y - padding)
                    x2 = min(image.shape[1], x + w + padding)
                    y2 = min(image.shape[0], y + h + padding)

                    coin_crop = masked_coin[y1:y2, x1:x2]
                    coin_crop = remove_black_background(coin_crop)

                    if coin_crop is not None and coin_crop.size > 0:
                        segmented_coins.append(coin_crop)

    result_img = original.copy()
    cv2.drawContours(result_img, valid_contours, -1, (0, 0, 255), 2)

    debug_images = {
        'Original': original,
        'Grayscale': gray,
        'Binary': binary,
        'After Closing': closing,
        'After Opening': opening,
        'Result': result_img
    }

    return result_img, segmented_coins, debug_images

def remove_black_background(image):
    if image is None or image.size == 0:
        return image

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    _, mask = cv2.threshold(gray, 5, 255, cv2.THRESH_BINARY)

    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if contours:
        largest_cnt = max(contours, key=cv2.contourArea)
        x, y, w, h = cv2.boundingRect(largest_cnt)
        return image[y:y+h, x:x+w]

    return image

def display_segmentation_results(result_img, segmented_coins, debug_images):
    plt.figure(figsize=(20, 10))

    for idx, (title, img) in enumerate(debug_images.items()):
        plt.subplot(2, 3, idx + 1)
        if len(img.shape) == 3:
            plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        else:
            plt.imshow(img, cmap='gray')
        plt.title(title)
        plt.axis('off')

    plt.tight_layout()
    plt.show()

    if segmented_coins:
        n_coins = len(segmented_coins)
        n_cols = min(4, n_coins)
        n_rows = (n_coins + 3) // 4

        plt.figure(figsize=(15, 3 * n_rows))
        for idx, coin in enumerate(segmented_coins):
            plt.subplot(n_rows, n_cols, idx + 1)
            plt.imshow(cv2.cvtColor(coin, cv2.COLOR_BGR2RGB))
            plt.title(f'Coin {idx + 1}')
            plt.axis('off')

        plt.tight_layout()
        plt.show()
    else:
        print("No coins were detected!")

result_img, segmented_coins, debug_images = segment(image_path)
display_segmentation_results(result_img, segmented_coins, debug_images)